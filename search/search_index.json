{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Contents - Features - Quick start - Credits Features \u00b6 This is a modern Cookiecutter template that can be used to initiate a Python project with all the necessary tools for development, testing, and deployment. It supports the following features: Poetry for dependency management CI/CD with GitHub Actions Pre-commit hooks with pre-commit Code quality with: black isort ruff mypy interrogate Checks dependencies for known security vulnerabilities with Safety All development tasks (lint, format, test, etc) wrapped up in a python CLI by duty Publishing to Pypi by creating a new release on GitHub Testing and coverage with pytest and codecov Documentation with MkDocs Compatibility testing for multiple versions of Python with Tox Auto-generated CHANGELOG.md from git commits (using Angular message style) commitizen Makefile for convenience Documentation - Example - PyPi Quickstart \u00b6 Install cookiecutter On your local machine, navigate to the directory in which you want to create a project directory, and run the following commands: pip install cookiecutter cookiecutter https://github.com/jexio/fulmo-cookiecutter-poetry.git Github repository Create a repository on GitHub, and then run the following commands, replacing `{project-name}`, with the name that you gave the Github repository and `{github_username}` with your Github username. cd <project_name> git init -b main git add . git commit -m \"Init commit\" git remote add origin git@github.com:<github_username>/<project_name>.git git push -u origin main Creating an environment Finally, install the environment and the pre-commit hooks with make install CI/CD and Docs You are now ready to start development on your project! The CI/CD pipeline will be triggered when you open a pull request, merge to main, or when you create a new release. To finalize the set-up for publishing to PyPi, see [here](https://jexio.github.io/fulmo-cookiecutter-poetry/features/publishing/#set-up-for-pypi/) For activating the automatic documentation with MkDocs, see [here](https://jexio.github.io/fulmo-cookiecutter-poetry/features/mkdocs/#enabling-the-documentation-on-github/) To enable the code coverage reports, see [here](https://jexio.github.io/fulmo-cookiecutter-poetry/features/codecov/) Credits \u00b6 This cookiecutter was built for learning purpose and inspired by: fedejaure/cookiecutter-modern-pypackage : Cookiecutter template for a modern Python package. pawamoy/copier-pdm : Copier template for Python projects managed by PDM. fpgmaas/cookiecutter-poetry : This is a modern Cookiecutter template that can be used to initiate a Python project with all the necessary tools for development, testing, and deployment. hypermodern-python : Hypermodern Python article series.","title":"Overview"},{"location":"#features","text":"This is a modern Cookiecutter template that can be used to initiate a Python project with all the necessary tools for development, testing, and deployment. It supports the following features: Poetry for dependency management CI/CD with GitHub Actions Pre-commit hooks with pre-commit Code quality with: black isort ruff mypy interrogate Checks dependencies for known security vulnerabilities with Safety All development tasks (lint, format, test, etc) wrapped up in a python CLI by duty Publishing to Pypi by creating a new release on GitHub Testing and coverage with pytest and codecov Documentation with MkDocs Compatibility testing for multiple versions of Python with Tox Auto-generated CHANGELOG.md from git commits (using Angular message style) commitizen Makefile for convenience Documentation - Example - PyPi","title":"Features"},{"location":"#quickstart","text":"Install cookiecutter On your local machine, navigate to the directory in which you want to create a project directory, and run the following commands: pip install cookiecutter cookiecutter https://github.com/jexio/fulmo-cookiecutter-poetry.git Github repository Create a repository on GitHub, and then run the following commands, replacing `{project-name}`, with the name that you gave the Github repository and `{github_username}` with your Github username. cd <project_name> git init -b main git add . git commit -m \"Init commit\" git remote add origin git@github.com:<github_username>/<project_name>.git git push -u origin main Creating an environment Finally, install the environment and the pre-commit hooks with make install CI/CD and Docs You are now ready to start development on your project! The CI/CD pipeline will be triggered when you open a pull request, merge to main, or when you create a new release. To finalize the set-up for publishing to PyPi, see [here](https://jexio.github.io/fulmo-cookiecutter-poetry/features/publishing/#set-up-for-pypi/) For activating the automatic documentation with MkDocs, see [here](https://jexio.github.io/fulmo-cookiecutter-poetry/features/mkdocs/#enabling-the-documentation-on-github/) To enable the code coverage reports, see [here](https://jexio.github.io/fulmo-cookiecutter-poetry/features/codecov/)","title":"Quickstart"},{"location":"#credits","text":"This cookiecutter was built for learning purpose and inspired by: fedejaure/cookiecutter-modern-pypackage : Cookiecutter template for a modern Python package. pawamoy/copier-pdm : Copier template for Python projects managed by PDM. fpgmaas/cookiecutter-poetry : This is a modern Cookiecutter template that can be used to initiate a Python project with all the necessary tools for development, testing, and deployment. hypermodern-python : Hypermodern Python article series.","title":"Credits"},{"location":"changelog/","text":"Unreleased \u00b6 bump: version 0.4.0 \u2192 0.4.1 bump: version 0.4.0 \u2192 0.4.1 fix(github): build wily cache before ranking for all files bump: version 0.3.1 \u2192 0.4.0 0.4.0 (2023-02-27) \u00b6 bump: version 0.3.1 \u2192 0.4.0 chore: update dependencies feat(tasks): extract total maintainability index from wily rank function docs: add wily badge chore: update dependencies chore: update python versions docs: fix broken links and size of cookie image ci(github): prevent generation commitizen hook if commitizen tool was rejected during project creation bump: version 0.3.0 \u2192 0.3.1 fix(tasks): fix broken name 0.3.0 (2023-02-27) \u00b6 bump: version 0.2.0 \u2192 0.3.0 docs: fix broken links fix(github): add interrogate tool in quality workflow feat(cookiecutter): add initial template for project generation feat(cli): add cli to run the cookiecutter with the directory passed test(cookiecutter): check that files that use the cookiecutter template insert data without errors feat(cookiecutter): add pre/post generation hooks feat(task): add makefile and cli to run development tasks For more details see docs/makefile.md chore(git): add initial git files The purpose of each file is described below: .gitignore file specifies intentionally untracked files that Git should ignore. Configuration file pre-commit-config.yaml for the framework to manage and support multi-language pre-commit hooks. chore(cookiecutter): add cookiecutter template chore(dependency): add initial poetry files docs: add template mkdocs.yml for static site generator MkDocs docs: add MIT license file chore(ide): add .editorconfig file ci(github): add initial workflow files Also add auxiliary files: Tox. A generic virtual environment management and test command line tool. docs: add initial documentations","title":"Changelog"},{"location":"changelog/#unreleased","text":"bump: version 0.4.0 \u2192 0.4.1 bump: version 0.4.0 \u2192 0.4.1 fix(github): build wily cache before ranking for all files bump: version 0.3.1 \u2192 0.4.0","title":"Unreleased"},{"location":"changelog/#040-2023-02-27","text":"bump: version 0.3.1 \u2192 0.4.0 chore: update dependencies feat(tasks): extract total maintainability index from wily rank function docs: add wily badge chore: update dependencies chore: update python versions docs: fix broken links and size of cookie image ci(github): prevent generation commitizen hook if commitizen tool was rejected during project creation bump: version 0.3.0 \u2192 0.3.1 fix(tasks): fix broken name","title":"0.4.0 (2023-02-27)"},{"location":"changelog/#030-2023-02-27","text":"bump: version 0.2.0 \u2192 0.3.0 docs: fix broken links fix(github): add interrogate tool in quality workflow feat(cookiecutter): add initial template for project generation feat(cli): add cli to run the cookiecutter with the directory passed test(cookiecutter): check that files that use the cookiecutter template insert data without errors feat(cookiecutter): add pre/post generation hooks feat(task): add makefile and cli to run development tasks For more details see docs/makefile.md chore(git): add initial git files The purpose of each file is described below: .gitignore file specifies intentionally untracked files that Git should ignore. Configuration file pre-commit-config.yaml for the framework to manage and support multi-language pre-commit hooks. chore(cookiecutter): add cookiecutter template chore(dependency): add initial poetry files docs: add template mkdocs.yml for static site generator MkDocs docs: add MIT license file chore(ide): add .editorconfig file ci(github): add initial workflow files Also add auxiliary files: Tox. A generic virtual environment management and test command line tool. docs: add initial documentations","title":"0.3.0 (2023-02-27)"},{"location":"prompt_arguments/","text":"Prompt arguments \u00b6 When running the command fcp a prompt will start which enables you to configure your repository. The prompt values and their explanation are as follows: author Your full name. email Your email address. github_username Your github handle, i.e. <handle> in https://github.com/<handle> project_name Your project name. Should be equal to the name of your repository and it should only contain alphanumeric characters and - 's. project_slug The project slug, will default to the project_name with all - 's replaced with _ . This will be how you import your code later, e.g. from < project_slug > import foo project_description A short description of your project. version A version of your project. include_github_actions \"y\" or \"n\" . Adds a .github directory with various actions and workflows to setup the environment and run code formatting checks and unittests. publish_to \"pypi\" or \"none\" . Adds functionality to the Makefile and Github workflows to make publishing your code as simple as creating a new release release on Github. mkdocs \"y\" or \"n\" . Adds MkDocs documentation to your project. This includes automatically parsing your docstrings and adding them to the documentation. Documentation will be deployed to the gh-pages branch. codecov \"y\" or \"n\" . Adds code coverage checks with codecov . commitizen \"y\" or \"n\" . Adds tool to generate meaningful commits commitizen . open_source_license Choose a license . Options: [\"1. MIT License\", \"2. BSD license\", \"3. ISC license\", \"4. Apache Software License 2.0\", \"5. GNU General Public License v3\", \"6. Not open source\"]","title":"Prompt Arguments"},{"location":"prompt_arguments/#prompt-arguments","text":"When running the command fcp a prompt will start which enables you to configure your repository. The prompt values and their explanation are as follows: author Your full name. email Your email address. github_username Your github handle, i.e. <handle> in https://github.com/<handle> project_name Your project name. Should be equal to the name of your repository and it should only contain alphanumeric characters and - 's. project_slug The project slug, will default to the project_name with all - 's replaced with _ . This will be how you import your code later, e.g. from < project_slug > import foo project_description A short description of your project. version A version of your project. include_github_actions \"y\" or \"n\" . Adds a .github directory with various actions and workflows to setup the environment and run code formatting checks and unittests. publish_to \"pypi\" or \"none\" . Adds functionality to the Makefile and Github workflows to make publishing your code as simple as creating a new release release on Github. mkdocs \"y\" or \"n\" . Adds MkDocs documentation to your project. This includes automatically parsing your docstrings and adding them to the documentation. Documentation will be deployed to the gh-pages branch. codecov \"y\" or \"n\" . Adds code coverage checks with codecov . commitizen \"y\" or \"n\" . Adds tool to generate meaningful commits commitizen . open_source_license Choose a license . Options: [\"1. MIT License\", \"2. BSD license\", \"3. ISC license\", \"4. Apache Software License 2.0\", \"5. GNU General Public License v3\", \"6. Not open source\"]","title":"Prompt arguments"},{"location":"tutorial/","text":"Tutorial \u00b6 This page contains a complete tutorial on how to create your project. Step 1: Install poetry \u00b6 To start, we will need to install poetry . The instructions to install poetry can be found here . After installing, it is recommended to run poetry config virtualenvs.in-project true which will by default create new virtual environments in ./.venv whenever you create them with poetry init . Step 2: Install pyenv (Optional) \u00b6 I would recommend to use pyenv for managing your different Python versions. However, if you prefer another method of managing your Python versions, feel free to skip this step and continue to step 3 . The instructions to install pyenv can be found here . The instructions to install poetry can be found here . Install a version of Python with pyenv. To see a list of available versions, run: pyenv install --list Select a version and install it with pyenv install -v 3 .9.7 Replacing 3.9.7 with a version of your choosing. Step 3: Generate your project \u00b6 First, navigate to the directory in which you want the project to be created. Then, we need to install fulmo-cookiecutter-poetry with the following command: pip install fulmo-cookiecutter-poetry Within the directory in which you want to create your project, run: fcp For an explanation of the prompt arguments, see Prompt Arguments . An alternative to the steps above would be to install cookiecutter and directly pass the URL to Github repository to the cookiecutter command: pip install fulmo-cookiecutter-poetry cookiecutter https://github.com/jexio/fulmo-cookiecutter-poetry.git Step 4: Set up your Github repository \u00b6 Create an empty new repository on Github. Give it a name that only contains alphanumeric characters and optionally - . DO NOT check any boxes under the option Initialize this repository with . Step 5: Upload your project to Github \u00b6 Run the following commands, replacing <project-name> with the name that you also gave the Github repository and <github_username> with your Github username. cd <project_name> git init -b main git add . git commit -m \"Init commit\" git remote add origin git@github.com:<github_username>/<project_name>.git git push -u origin main Step 6: Activate your environment \u00b6 If you are using pyenv , you might want to set the local python version to be used: pyenv local x.y.z Install and activate the poetry environment by running: make install poetry shell Step 7: Sign up to codecov.io \u00b6 If you enabled code coverage with codecov for your project, you should sign up with your GitHub account at codecov.io Step 8: Configure your repository secrets \u00b6 If you want to deploy your project to Pypi using the Github Actions, you will have to set some repository secrets. For instructions on how to do that, see here for PyPi. Step 9: Create a new release \u00b6 To trigger a new release, navigate to your repository on GitHub, click Releases on the right, and then select Draft a new release . If you fail to find the button, you could also directly visit https://github.com/<username>/<repository-name>/releases/new . Give your release a title, and add a new tag in the form *.*.* where the * 's are alphanumeric. To finish, press Publish release . Step 10: Enable your documentation \u00b6 In your repository, navigate to Settings > Code and Automation > Pages . If you succesfully created a new release, you should see a notification saying Your site is ready to be published at https://<github_username>.github.io/<project_name>/ . To finalize deploying your documentation, under Source , select the branch gh-pages . Step 11: You're all set! \u00b6 That's it! I hope this repository saved you a lot of manual configuration. If you have any improvement suggestions, feel free to raise an issue or open a PR on Github!","title":"Tutorial"},{"location":"tutorial/#tutorial","text":"This page contains a complete tutorial on how to create your project.","title":"Tutorial"},{"location":"tutorial/#step-1-install-poetry","text":"To start, we will need to install poetry . The instructions to install poetry can be found here . After installing, it is recommended to run poetry config virtualenvs.in-project true which will by default create new virtual environments in ./.venv whenever you create them with poetry init .","title":"Step 1: Install poetry"},{"location":"tutorial/#step-2-install-pyenv-optional","text":"I would recommend to use pyenv for managing your different Python versions. However, if you prefer another method of managing your Python versions, feel free to skip this step and continue to step 3 . The instructions to install pyenv can be found here . The instructions to install poetry can be found here . Install a version of Python with pyenv. To see a list of available versions, run: pyenv install --list Select a version and install it with pyenv install -v 3 .9.7 Replacing 3.9.7 with a version of your choosing.","title":"Step 2: Install pyenv (Optional)"},{"location":"tutorial/#step-3-generate-your-project","text":"First, navigate to the directory in which you want the project to be created. Then, we need to install fulmo-cookiecutter-poetry with the following command: pip install fulmo-cookiecutter-poetry Within the directory in which you want to create your project, run: fcp For an explanation of the prompt arguments, see Prompt Arguments . An alternative to the steps above would be to install cookiecutter and directly pass the URL to Github repository to the cookiecutter command: pip install fulmo-cookiecutter-poetry cookiecutter https://github.com/jexio/fulmo-cookiecutter-poetry.git","title":"Step 3: Generate your project"},{"location":"tutorial/#step-4-set-up-your-github-repository","text":"Create an empty new repository on Github. Give it a name that only contains alphanumeric characters and optionally - . DO NOT check any boxes under the option Initialize this repository with .","title":"Step 4: Set up your Github repository"},{"location":"tutorial/#step-5-upload-your-project-to-github","text":"Run the following commands, replacing <project-name> with the name that you also gave the Github repository and <github_username> with your Github username. cd <project_name> git init -b main git add . git commit -m \"Init commit\" git remote add origin git@github.com:<github_username>/<project_name>.git git push -u origin main","title":"Step 5: Upload your project to Github"},{"location":"tutorial/#step-6-activate-your-environment","text":"If you are using pyenv , you might want to set the local python version to be used: pyenv local x.y.z Install and activate the poetry environment by running: make install poetry shell","title":"Step 6: Activate your environment"},{"location":"tutorial/#step-7-sign-up-to-codecovio","text":"If you enabled code coverage with codecov for your project, you should sign up with your GitHub account at codecov.io","title":"Step 7: Sign up to codecov.io"},{"location":"tutorial/#step-8-configure-your-repository-secrets","text":"If you want to deploy your project to Pypi using the Github Actions, you will have to set some repository secrets. For instructions on how to do that, see here for PyPi.","title":"Step 8: Configure your repository secrets"},{"location":"tutorial/#step-9-create-a-new-release","text":"To trigger a new release, navigate to your repository on GitHub, click Releases on the right, and then select Draft a new release . If you fail to find the button, you could also directly visit https://github.com/<username>/<repository-name>/releases/new . Give your release a title, and add a new tag in the form *.*.* where the * 's are alphanumeric. To finish, press Publish release .","title":"Step 9: Create a new release"},{"location":"tutorial/#step-10-enable-your-documentation","text":"In your repository, navigate to Settings > Code and Automation > Pages . If you succesfully created a new release, you should see a notification saying Your site is ready to be published at https://<github_username>.github.io/<project_name>/ . To finalize deploying your documentation, under Source , select the branch gh-pages .","title":"Step 10: Enable your documentation"},{"location":"tutorial/#step-11-youre-all-set","text":"That's it! I hope this repository saved you a lot of manual configuration. If you have any improvement suggestions, feel free to raise an issue or open a PR on Github!","title":"Step 11: You're all set!"},{"location":"features/cicd/","text":"CI/CD with Github actions \u00b6 when include_github_actions is set to \"y\" , a .github directory is added with the following structure: .github \u251c\u2500\u2500 workflows \u251c\u2500\u2500\u2500 run-checks \u2502 \u2514\u2500\u2500 action.yml \u251c\u2500\u2500\u2500 setup-poetry-env \u2502 \u2514\u2500\u2500 action.yml \u251c\u2500\u2500 on-merge-to-main.yml \u251c\u2500\u2500 on-pull-request.yml \u2514\u2500\u2500 on-release-main.yml on-merge-to-main.yml and on-pull-request.yml are identical except for their trigger conditions; the first is run whenever a new commit is made to main (which should only happen through merge requests, hence the name), and the latter is run whenever a pull request is opened or updated. They call the action.yml files to set-up the environment, run the tests, and check the code formatting. on-release-main.yml does all of the former whenever a new release is made on the main branch. In addition, on-release-main.yml also publishes the project to Pypi if publish_to is set to \"pypi\" , and it builds and deploys the documentation if mkdocs is set to \"y\" . To learn more about these features, see Publishing to PyPi and Documentation with MkDocs Additionally, all workflows check for compatibility with multiple Python versions if tox is set to \"y\" . How to trigger a release? \u00b6 To trigger a new release, navigate to your repository on GitHub, click Releases on the right, and then select Draft a new release . If you fail to find the button, you could also directly visit https://github.com/<username>/<repository-name>/releases/new . Give your release a title, and add a new tag in the form *.*.* where the * 's are alphanumeric. To finish, press Publish release .","title":"CI/CD with Github Actions"},{"location":"features/cicd/#cicd-with-github-actions","text":"when include_github_actions is set to \"y\" , a .github directory is added with the following structure: .github \u251c\u2500\u2500 workflows \u251c\u2500\u2500\u2500 run-checks \u2502 \u2514\u2500\u2500 action.yml \u251c\u2500\u2500\u2500 setup-poetry-env \u2502 \u2514\u2500\u2500 action.yml \u251c\u2500\u2500 on-merge-to-main.yml \u251c\u2500\u2500 on-pull-request.yml \u2514\u2500\u2500 on-release-main.yml on-merge-to-main.yml and on-pull-request.yml are identical except for their trigger conditions; the first is run whenever a new commit is made to main (which should only happen through merge requests, hence the name), and the latter is run whenever a pull request is opened or updated. They call the action.yml files to set-up the environment, run the tests, and check the code formatting. on-release-main.yml does all of the former whenever a new release is made on the main branch. In addition, on-release-main.yml also publishes the project to Pypi if publish_to is set to \"pypi\" , and it builds and deploys the documentation if mkdocs is set to \"y\" . To learn more about these features, see Publishing to PyPi and Documentation with MkDocs Additionally, all workflows check for compatibility with multiple Python versions if tox is set to \"y\" .","title":"CI/CD with Github actions"},{"location":"features/cicd/#how-to-trigger-a-release","text":"To trigger a new release, navigate to your repository on GitHub, click Releases on the right, and then select Draft a new release . If you fail to find the button, you could also directly visit https://github.com/<username>/<repository-name>/releases/new . Give your release a title, and add a new tag in the form *.*.* where the * 's are alphanumeric. To finish, press Publish release .","title":"How to trigger a release?"},{"location":"features/codecov/","text":"Test coverage with codecov \u00b6 If codecov is set to \"y\" , pytest-cov is added as a development dependency, and make test will run the tests and output a coverage report as coverage.xml . If include_github_actions is set to \"y\" , coverage tests with codecov are added to the CI/CD pipeline. To enable this, sign up at codecov.io with your GitHub account. Additionally, a codecov.yaml file is created, with the following defaults: # Badge color changes from red to green between 70% and 100% # PR pipeline fails if codecov falls with 1% coverage : range : 70..100 round : down precision : 1 status : project : default : target : auto threshold : 1% # Ignoring Paths # -------------- # which folders/files to ignore ignore : - \"foo/bar.py\"","title":"Test coverage with codecov"},{"location":"features/codecov/#test-coverage-with-codecov","text":"If codecov is set to \"y\" , pytest-cov is added as a development dependency, and make test will run the tests and output a coverage report as coverage.xml . If include_github_actions is set to \"y\" , coverage tests with codecov are added to the CI/CD pipeline. To enable this, sign up at codecov.io with your GitHub account. Additionally, a codecov.yaml file is created, with the following defaults: # Badge color changes from red to green between 70% and 100% # PR pipeline fails if codecov falls with 1% coverage : range : 70..100 round : down precision : 1 status : project : default : target : auto threshold : 1% # Ignoring Paths # -------------- # which folders/files to ignore ignore : - \"foo/bar.py\"","title":"Test coverage with codecov"},{"location":"features/linting/","text":"Linting and code quality \u00b6 Code can be linted and quality-checked with the command make check Note that this requires the pre-commit hooks to be installed. This command will run the following tools: black \u00b6 black is used to format the code, and it is configured through pyproject.toml : [tool.black] line-length = 120 include = '\\.pyi?$' target-version = [ \"py310\" ] fast = true To exclude directories or files, add an exclude argument to pre-commit-config.yaml . Note that adding an exclude argument to pyproject.toml will not work, see also here . ruff \u00b6 ruff is used to check the code style, and it is configured through pyproject.toml : [tool.ruff] target-version = \"py310\" line-length = 120 select = [ \"ALL\" ] ignore = [ \"A001\", # Variable is shadowing a Python builtin \"ANN101\", # Missing type annotation for self \"ANN401\", # Dynamically typed expressions (typing.Any) are disallowed \"C901\", # Too complex \"D105\", # Missing docstring in magic method \"D417\", # Missing argument description in the docstring \"E501\", # Line too long \"PLR0911\", # Too many return statements \"PLR0912\", # Too many branches \"PLR0913\", # Too many arguments to function call \"PLR0915\", # Too many statements \"TRY003\", # Avoid specifying long messages outside the exception class ] [tool.ruff.per-file-ignores] \"scripts/*.py\" = [ \"INP001\", # File is part of an implicit namespace package ] \"tests/*.py\" = [ \"ANN\", # Missing/wrong type annotations \"ARG005\", # Unused lambda argument \"PLR2004\", # Magic value used in comparison \"S101\", # Use of assert detected ] \"hooks/*.py\" = [ \"PLR0133\", # Two constants compared in a comparison, consider replacing \"FBT001\", # Boolean positional arg in function definition \"FBT002\", # Boolean default value in function definition ] \"*/*__init__.py\" = [ \"D104\", # Missing docstring in public package ] [tool.ruff.flake8-type-checking] strict = true [tool.ruff.flake8-quotes] docstring-quotes = \"double\" [tool.ruff.flake8-tidy-imports] ban-relative-imports = \"all\" [tool.ruff.isort] known-first-party = [\"fulmo_cookiecutter_poetry\"] [tool.ruff.pydocstyle] convention = \"google\" mypy \u00b6 mypy is used for static type checking, and it's configuration and can be edited in pyproject.toml . [tool.mypy] warn_return_any = \"True\" warn_unused_ignores = \"True\" show_error_codes = \"True\" exclude = [ '{{cookiecutter.project_name}}' ]","title":"Linting & code quality"},{"location":"features/linting/#linting-and-code-quality","text":"Code can be linted and quality-checked with the command make check Note that this requires the pre-commit hooks to be installed. This command will run the following tools:","title":"Linting and code quality"},{"location":"features/linting/#black","text":"black is used to format the code, and it is configured through pyproject.toml : [tool.black] line-length = 120 include = '\\.pyi?$' target-version = [ \"py310\" ] fast = true To exclude directories or files, add an exclude argument to pre-commit-config.yaml . Note that adding an exclude argument to pyproject.toml will not work, see also here .","title":"black"},{"location":"features/linting/#ruff","text":"ruff is used to check the code style, and it is configured through pyproject.toml : [tool.ruff] target-version = \"py310\" line-length = 120 select = [ \"ALL\" ] ignore = [ \"A001\", # Variable is shadowing a Python builtin \"ANN101\", # Missing type annotation for self \"ANN401\", # Dynamically typed expressions (typing.Any) are disallowed \"C901\", # Too complex \"D105\", # Missing docstring in magic method \"D417\", # Missing argument description in the docstring \"E501\", # Line too long \"PLR0911\", # Too many return statements \"PLR0912\", # Too many branches \"PLR0913\", # Too many arguments to function call \"PLR0915\", # Too many statements \"TRY003\", # Avoid specifying long messages outside the exception class ] [tool.ruff.per-file-ignores] \"scripts/*.py\" = [ \"INP001\", # File is part of an implicit namespace package ] \"tests/*.py\" = [ \"ANN\", # Missing/wrong type annotations \"ARG005\", # Unused lambda argument \"PLR2004\", # Magic value used in comparison \"S101\", # Use of assert detected ] \"hooks/*.py\" = [ \"PLR0133\", # Two constants compared in a comparison, consider replacing \"FBT001\", # Boolean positional arg in function definition \"FBT002\", # Boolean default value in function definition ] \"*/*__init__.py\" = [ \"D104\", # Missing docstring in public package ] [tool.ruff.flake8-type-checking] strict = true [tool.ruff.flake8-quotes] docstring-quotes = \"double\" [tool.ruff.flake8-tidy-imports] ban-relative-imports = \"all\" [tool.ruff.isort] known-first-party = [\"fulmo_cookiecutter_poetry\"] [tool.ruff.pydocstyle] convention = \"google\"","title":"ruff"},{"location":"features/linting/#mypy","text":"mypy is used for static type checking, and it's configuration and can be edited in pyproject.toml . [tool.mypy] warn_return_any = \"True\" warn_unused_ignores = \"True\" show_error_codes = \"True\" exclude = [ '{{cookiecutter.project_name}}' ]","title":"mypy"},{"location":"features/makefile/","text":"Makefile \u00b6 The generated repository will have a Makefile available. A list of all available commands that are available can be obtained by running make help in the terminal. Initially, if all features are selected, the following commands are available: install Install the poetry environment and install the pre-commit hooks. pre-commit-install Install pre-commit hooks. check Lint and check code and docstrings by running black, ruff, mypy, safety, interrogate. test Test the code with pytest build Build wheel file using poetry clean clean build, test and linting artifacts publish publish a release to pypi. build-and-publish Build and publish. docs-build Build the documentation locally. docs-test Test if documentation can be built without warnings or errors. docs Build and serve the documentation.","title":"Makefile"},{"location":"features/makefile/#makefile","text":"The generated repository will have a Makefile available. A list of all available commands that are available can be obtained by running make help in the terminal. Initially, if all features are selected, the following commands are available: install Install the poetry environment and install the pre-commit hooks. pre-commit-install Install pre-commit hooks. check Lint and check code and docstrings by running black, ruff, mypy, safety, interrogate. test Test the code with pytest build Build wheel file using poetry clean clean build, test and linting artifacts publish publish a release to pypi. build-and-publish Build and publish. docs-build Build the documentation locally. docs-test Test if documentation can be built without warnings or errors. docs Build and serve the documentation.","title":"Makefile"},{"location":"features/mkdocs/","text":"Documentation with MkDocs \u00b6 If mkdocs is set to \"y\" , documentation of your project is automatically added using MkDocs . Next to that, if \"include_github_actions\" is set to \"y\" , the documentation is automatically deployed to your gh-pages branch, and made available at https://<github_username>.github.io/<project_name>/ . To view the documentation locally, simply run make docs This command will generate and build your documentation, and start the server locally so you can access it at http://localhost:8000 . Enabling the documentation on GitHub \u00b6 To enable your documentation on GitHub, first create a new release . Then, in your repository, navigate to Settings > Code and Automation > Pages . If you succesfully created a new release, you should see a notification saying Your site is ready to be published at https://<github_username>.github.io/<project_name>/ . To finalize deploying your documentation, under Source , select the branch gh-pages . Your documentation should then be live within a few minutes. Documenting docstrings \u00b6 The generated project also converts all your docstrings into legible documentation. By default, the project is configured to work with google style docstrings. An example of a Google style docstring: def function_with_pep484_type_annotations ( param1 : int , param2 : str ) -> bool : \"\"\"Example function with PEP 484 type annotations. Args: param1: The first parameter. param2: The second parameter. Returns: The return value. True for success, False otherwise. For more examples, see here .","title":"Documentation with MkDocs"},{"location":"features/mkdocs/#documentation-with-mkdocs","text":"If mkdocs is set to \"y\" , documentation of your project is automatically added using MkDocs . Next to that, if \"include_github_actions\" is set to \"y\" , the documentation is automatically deployed to your gh-pages branch, and made available at https://<github_username>.github.io/<project_name>/ . To view the documentation locally, simply run make docs This command will generate and build your documentation, and start the server locally so you can access it at http://localhost:8000 .","title":"Documentation with MkDocs"},{"location":"features/mkdocs/#enabling-the-documentation-on-github","text":"To enable your documentation on GitHub, first create a new release . Then, in your repository, navigate to Settings > Code and Automation > Pages . If you succesfully created a new release, you should see a notification saying Your site is ready to be published at https://<github_username>.github.io/<project_name>/ . To finalize deploying your documentation, under Source , select the branch gh-pages . Your documentation should then be live within a few minutes.","title":"Enabling the documentation on GitHub"},{"location":"features/mkdocs/#documenting-docstrings","text":"The generated project also converts all your docstrings into legible documentation. By default, the project is configured to work with google style docstrings. An example of a Google style docstring: def function_with_pep484_type_annotations ( param1 : int , param2 : str ) -> bool : \"\"\"Example function with PEP 484 type annotations. Args: param1: The first parameter. param2: The second parameter. Returns: The return value. True for success, False otherwise. For more examples, see here .","title":"Documenting docstrings"},{"location":"features/poetry/","text":"Dependency management with Poetry \u00b6 The generated repository will uses Poetry for its dependency management. When you have created your repository using this cookiecutter template, a Poetry environment is pre-configured in pyproject.toml and Poetry.toml . All you need to do is add your project-specific dependencies with poetry add <package> and then install the environment with make install By default, the environment is created in a .venv folder, so you can easily start an interactive shell within the environment with poetry shell .","title":"Dependency management with Poetry"},{"location":"features/poetry/#dependency-management-with-poetry","text":"The generated repository will uses Poetry for its dependency management. When you have created your repository using this cookiecutter template, a Poetry environment is pre-configured in pyproject.toml and Poetry.toml . All you need to do is add your project-specific dependencies with poetry add <package> and then install the environment with make install By default, the environment is created in a .venv folder, so you can easily start an interactive shell within the environment with poetry shell .","title":"Dependency management with Poetry"},{"location":"features/publishing/","text":"Publishing to Pypi \u00b6 Releasing from Github \u00b6 When publish_to is set to \"pypi\" , the on-release-main.yml workflow publishes the code to Pypi whenever a new release is made. Before you can succesfully publish your project from the release workflow, you need to add some secrets to your github repository so they can be used as environment variables. Set-up for Pypi \u00b6 In order to publish to Pypi, the secret PYPI_TOKEN should be set in your repository. In your Github repository, navigate to Settings > Secrets > Actions and press New repository secret . As the name of the secret, set PYPI_TOKEN . Then, in a new tab go to your Pypi Account settings and select Add API token . Copy and paste the token in the Value field for the Github secret in your first tab, and you're all set! Publishing from your local machine \u00b6 It is also possible to release locally, although it is not recommended. To do so, set the repository secrets listed in the sections above as environment variables on your local machine instead, and run make build-and-publish","title":"Publishing to PyPi"},{"location":"features/publishing/#publishing-to-pypi","text":"","title":"Publishing to Pypi"},{"location":"features/publishing/#releasing-from-github","text":"When publish_to is set to \"pypi\" , the on-release-main.yml workflow publishes the code to Pypi whenever a new release is made. Before you can succesfully publish your project from the release workflow, you need to add some secrets to your github repository so they can be used as environment variables.","title":"Releasing from Github"},{"location":"features/publishing/#set-up-for-pypi","text":"In order to publish to Pypi, the secret PYPI_TOKEN should be set in your repository. In your Github repository, navigate to Settings > Secrets > Actions and press New repository secret . As the name of the secret, set PYPI_TOKEN . Then, in a new tab go to your Pypi Account settings and select Add API token . Copy and paste the token in the Value field for the Github secret in your first tab, and you're all set!","title":"Set-up for Pypi"},{"location":"features/publishing/#publishing-from-your-local-machine","text":"It is also possible to release locally, although it is not recommended. To do so, set the repository secrets listed in the sections above as environment variables on your local machine instead, and run make build-and-publish","title":"Publishing from your local machine"},{"location":"features/pytest/","text":"Unittesting with Pytest \u00b6 pytest is automatically added to the environment. There will be a template unittest in the tests directory upon creation of the project, which can be run with make test If include_github_actions is set to \"y\" , the tests are automatically run for every merge request, every merge to main, and every release.","title":"Testing with Pytest"},{"location":"features/pytest/#unittesting-with-pytest","text":"pytest is automatically added to the environment. There will be a template unittest in the tests directory upon creation of the project, which can be run with make test If include_github_actions is set to \"y\" , the tests are automatically run for every merge request, every merge to main, and every release.","title":"Unittesting with Pytest"},{"location":"features/tox/","text":"Compatibility testing with Tox \u00b6 If tox is set to \"y\" project uses Tox to test compatibility with multiple Python versions. By default, the project is tested with Python 3.10 and 3.11 . Testing is done automatically in the CI/CD pipeline on every pull request, merge to main, and on each release. If you want to add more Python versions you can simply add them to tox.ini and to the separate workflows in .github .","title":"Compatibility testing with Tox"},{"location":"features/tox/#compatibility-testing-with-tox","text":"If tox is set to \"y\" project uses Tox to test compatibility with multiple Python versions. By default, the project is tested with Python 3.10 and 3.11 . Testing is done automatically in the CI/CD pipeline on every pull request, merge to main, and on each release. If you want to add more Python versions you can simply add them to tox.ini and to the separate workflows in .github .","title":"Compatibility testing with Tox"}]}